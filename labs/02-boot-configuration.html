<h1 id="spring-boot-auto-configuration-for-tanzu-gemfire">Spring Boot Auto-configuration for Tanzu GemFire</h1>
<p>Suppose we need to create a customer service application that stores customer data and allows the user to
search for customers by name. This lab is a modified version of the guide provided by John Blum at
<a href="https://docs.spring.io/spring-boot-data-geode-build/current/reference/html5/guides/boot-configuration.html">apache-geode-docs</a></p>
<p>We will walk you through building a simple Customer Service Spring Boot application using Apache Geode
to manage Customer interactions. You should already be familiar with Spring Boot and Apache Geode.</p>
<p>By the end of this lesson, you should have a better understanding of what Spring Boot for Apache Geode’s (SBDG)
<em>auto-configuration</em> support actually does. Additional resources can be found here:
link:<a href="https://docs.spring.io/spring-boot-data-geode-build/current/reference/html5/guides/boot-configuration.html">https://docs.spring.io/spring-boot-data-geode-build/current/reference/html5/guides/boot-configuration.html</a>
link:<a href="https://docs.spring.io/spring-boot-data-geode-build/current/reference/html5/index.html#geode-samples">https://docs.spring.io/spring-boot-data-geode-build/current/reference/html5/index.html#geode-samples</a></p>
<p>You can either work from an editor, vscode (code) or Spring Tool Suite. The directory for the first lab project
can be found by:</p>
<pre><code class="lang-bash"><span class="hljs-built_in">cd</span> spring-geode-workshop/configuration
</code></pre>
<p>Your choice of command line editors are</p>
<ul>
<li>emacs</li>
<li>vi</li>
</ul>
<p>and your choice of IDEs available from the command line that are found on your $PATH are:</p>
<ul>
<li>SpringToolSuite4</li>
<li>code</li>
</ul>
<p>The packages and classes have been previously created. You will want to review the code and pay special attention to the
annotations for he respective stereotypes used in the solution for the lab.  In Visual Studio Code simply Open the Folder
listed above and accept the prompts for the java and maven plugins.
vscode project: <img src="/Users/wlund/Dropbox/git-workspace/wxlund/spring-geode-workshop/labs/images/vscode-open-auto-configuration-project.png" alt="Alt"></p>
<p>Wih the configuration project open you will be able to navigate through the various packages to review the src code
under the standard src folder (src/main/java) as shown below:</p>
<p>Review Src Code: <img src="/Users/wlund/Dropbox/git-workspace/wxlund/spring-geode-workshop/labs/images/vscode-review-solution-src-code.png" alt="Alt"></p>
<p>With Spring Tool Suite you follow a similar approach.</p>
<ol>
<li>Select Import an existing maven project and navigate to spring-geode-workshop/configuration as shown below:
<img src="/Users/wlund/Dropbox/git-workspace/wxlund/spring-geode-workshop/labs/images/sts-navigate-folder-to-import.png" alt="Alt"></li>
<li>Then import the mvn project.  You will see the project configure and compile the mvn project.
<img src="/Users/wlund/Dropbox/git-workspace/wxlund/spring-geode-workshop/labs/images/sts-import-mvn-project.png" alt="Alt"></li>
<li>Review the project source code packages and classes: :
<img src="/Users/wlund/Dropbox/git-workspace/wxlund/spring-geode-workshop/labs/images/sts-review-src-code.png" alt="Alt"></li>
</ol>
<h2 id="application-domain-classes">Application Domain Classes</h2>
<p>We will review the src code from the view of building the Spring Boot, Customer Service application from the ground up.</p>
<h3 id="-customer-class"><code>Customer</code> class</h3>
<p>First, we need to define an application domain object to encapsulate customer information. We begin by modeling the data our
application needs to manage, namely a <code>Customer</code>. For this example, the <code>Customer</code> class is implemented as follows:</p>
<p><strong>Customer class.</strong></p>
<pre><code class="lang-java">@Region(<span class="hljs-string">"Customers"</span>)
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Customer</span>&lt;<span class="hljs-title">T</span>&gt; </span>{

    @Id
    <span class="hljs-keyword">private</span> Long id;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">String</span> name;

    <span class="hljs-keyword">private</span> Customer(Long id, <span class="hljs-keyword">String</span> name) {
        <span class="hljs-keyword">if</span> ((id == <span class="hljs-literal">null</span>) ||name == <span class="hljs-literal">null</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-type">NullPointerException</span>(<span class="hljs-string">"name required"</span>);
        <span class="hljs-built_in">this</span>.id = id;
        <span class="hljs-built_in">this</span>.name = (<span class="hljs-keyword">String</span>) name;
    }

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; Customer&lt;T&gt; <span class="hljs-keyword">new</span><span class="hljs-type">Customer</span>(Long id, <span class="hljs-keyword">String</span> name) {
         <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-type">Customer</span>&lt;T&gt;(id, name);
        }
}
</code></pre>
<p>The <code>Customer</code> class is annotated with Spring Data Geode’s (SDG) <code>@Region</code> annotation. <code>@Region</code>
is a mapping annotation declaring the Apache Geode cache <code>Region</code> in which <code>Customer</code> data will
be persisted.  A <code>Region</code> is a distributed version of <code>java.util.Map</code>.</p>
<p>Tthe <code>@Id</code> annotation is used to designate the <code>Customer.id</code> field as
the identifier for <code>Customer</code> objects. The identifier is the Key used in the Entry stored in the &quot;Customers&quot;`Region`.
A <code>Region</code> is a distributed version of <code>java.util.Map</code>.</p>
<h3 id="-customerrepository-interface"><code>CustomerRepository</code> interface</h3>
<p>Next, we create a <em>Data Access Object</em> (DAO) to persist <code>Customers</code> to Apache Geode. We create the DAO
using Spring Data’s <em>Repository</em> abstraction:</p>
<p><strong>CustomerRepository interface.</strong></p>
<pre><code><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">CustomerRepository</span> <span class="hljs-keyword"><span class="hljs-keyword">extends</span> <span class="hljs-type">CrudRepository</span></span>&lt;<span class="hljs-title">Customer</span>, <span class="hljs-title">Long</span>&gt; </span>{

    Customer findByNameLike(<span class="hljs-keyword">String</span> name);

}
</code></pre><p><code>CustomerRepository</code> is a Spring Data <code>CrudRepository</code>. <code>CrudRepository</code> provides basic CRUD (CREATE, READ, UPDATE,
and DELETE) data access operations along with the ability to define simple queries on <code>Customers</code>.</p>
<p>Spring Data Geode will create a proxy implementation for your application-specific <em>Repository</em> interfaces, implementing
any query methods you may have explicitly defined on the interface in addition to the data access operations provided in
the <code>CrudRepository</code> interface extension.</p>
<p>In addition to the base <code>CrudRepository</code> operations, <code>CustomerRepository</code> has additionally defined a
<code>findByNameLike(:String):Customer</code> query method. </p>
<h3 id="-customerserviceapplication-spring-boot-main-class-"><code>CustomerServiceApplication</code> (Spring Boot main class)</h3>
<p>Now that we have created the basic domain classes of our Customer Service application, we need a main application class
to drive the interactions with Customers:</p>
<p><strong>CustomerServiceApplication class.</strong></p>
<p><strong>CustomerServiceApplication class.</strong></p>
<pre><code class="lang-java">@<span class="hljs-type">SpringBootApplication</span>
@<span class="hljs-type">EnableClusterAware</span>
@<span class="hljs-type">EnableEntityDefinedRegions</span>(basePackageClasses = <span class="hljs-type">Customer</span>.<span class="hljs-keyword">class</span>)
public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CustomerServiceApplication</span> {</span>

    public static void main(<span class="hljs-type">String</span>[] args) {

        <span class="hljs-function"><span class="hljs-keyword">new</span> <span class="hljs-title">SpringApplicationBuilder</span>(<span class="hljs-type">CustomerServiceApplication</span>.class)
            .<span class="hljs-title">web</span>(<span class="hljs-type">WebApplicationType</span>.<span class="hljs-type">NONE</span>)
            .<span class="hljs-title">build</span>()
            .<span class="hljs-title">run</span>(args);
    }

    @<span class="hljs-title">Bean</span>
    <span class="hljs-title">ApplicationRunner</span> <span class="hljs-title">runner</span>(<span class="hljs-type">CustomerRepository</span> customerRepository) {

        <span class="hljs-title">Fairy</span> <span class="hljs-title">fairy</span> = <span class="hljs-title">Fairy</span>.<span class="hljs-title">create</span>();

        <span class="hljs-comment">// Generate a random name from data generator</span>
        <span class="hljs-title">Person</span> <span class="hljs-title">person</span> = <span class="hljs-title">fairy</span>.<span class="hljs-title">person</span>();


    <span class="hljs-title">return</span> <span class="hljs-title">args</span> -&gt; {
            <span class="hljs-comment">// Locating the max id to be enable incrementing of our ID.</span>
            <span class="hljs-title">Long</span> <span class="hljs-title">id</span> = 0<span class="hljs-title">L</span>;
            <span class="hljs-title">id</span> = <span class="hljs-title">customerRepository</span>.<span class="hljs-title">count</span>();

            <span class="hljs-title">assertThat</span>(customerRepository.count()).<span class="hljs-title">isEqualTo</span>(id);

            <span class="hljs-title">Customer</span> <span class="hljs-title">randomCustomer</span> = <span class="hljs-title">Customer</span>.<span class="hljs-title">newCustomer</span>(id + <span class="hljs-number">1</span>L, person.fullName());

            <span class="hljs-title">System</span>.<span class="hljs-title">err</span>.<span class="hljs-title">printf</span>("<span class="hljs-type">Saving</span> <span class="hljs-type">Customer</span> [%s]%n", randomCustomer);

            <span class="hljs-title">randomCustomer</span> = <span class="hljs-title">customerRepository</span>.<span class="hljs-title">save</span>(randomCustomer);

            <span class="hljs-title">assertThat</span>(randomCustomer).<span class="hljs-title">isNotNull</span>();
            <span class="hljs-title">assertThat</span>(randomCustomer.getId()).<span class="hljs-title">isEqualTo</span>(id + <span class="hljs-number">1</span>);
            <span class="hljs-title">assertThat</span>(randomCustomer.getName()).<span class="hljs-title">isEqualTo</span>(person.fullName());
            <span class="hljs-title">assertThat</span>(customerRepository.count()).<span class="hljs-title">isEqualTo</span>(randomCustomer.getId());

            <span class="hljs-title">String</span> <span class="hljs-title">query</span> = "<span class="hljs-title">Querying</span> <span class="hljs-title">for</span> <span class="hljs-title">Customer</span> [<span class="hljs-title">SELECT</span> * <span class="hljs-title">FROM</span> /<span class="hljs-title">Customers</span> <span class="hljs-title">WHERE</span> <span class="hljs-title">name</span> <span class="hljs-title">LIKE</span> " + <span class="hljs-title">randomCustomer</span>.<span class="hljs-title">getName</span>() + "]";
            <span class="hljs-title">System</span>.<span class="hljs-title">err</span>.<span class="hljs-title">println</span>(query);

            <span class="hljs-title">Customer</span> <span class="hljs-title">queriedrandomCustomer</span> = <span class="hljs-title">customerRepository</span>.<span class="hljs-title">findByNameLike</span>(person.fullName());

            <span class="hljs-title">assertThat</span>(queriedrandomCustomer).<span class="hljs-title">isEqualTo</span>(randomCustomer);

            <span class="hljs-title">System</span>.<span class="hljs-title">err</span>.<span class="hljs-title">printf</span>("<span class="hljs-type">Customer</span> was [%s]%n", queriedrandomCustomer);
        };
    }
}</span>
</code></pre>
<p>The <code>CustomerServiceApplication</code> class is annotated with <code>@SpringBootApplication</code>. Therefore, the main class is
a proper Spring Boot application equipped with all the features of Spring Boot (e.g. <em>auto-configuration</em>).</p>
<p>We then use a @ClusterAware annotation.  &quot;The @EnableClusterAware annotation is arguably the most powerful and 
valuable Annotation in the set of Annotations!&quot; - <a href="https://docs.spring.io/spring-boot-data-geode-build/current/reference/html5/#geode-configuration-declarative-annotations-productivity-enableclusteraware">See here</a>.</p>
<p>We use @EnableEntityDefinedRegions(basePackageClasses = Customer.class) to locate our Domain class
that has our region annotation so that the Region will be created in whatever topology is deployed. </p>
<p>We use Spring Boot’s <code>SpringApplicationBuilder</code> in the <code>main</code> method to configure and bootstrap
the Customer Service application.</p>
<p>Then, we declare a Spring Boot <code>ApplicationRunner</code> bean, which is invoked by Spring Boot after the Spring container
(i.e. <code>ApplicationContext</code>) has been properly initialized and started. Our <code>ApplicationRunner</code> defines the Customer
interactions performed by our Customer Service application.</p>
<p>Specifically, the runner creates a new random <code>Customer</code> object generated through a mock data generator
called <a href="https://github.com/Devskiller/jfairy_ saves him to the &quot;Customers&quot; Region, and then
queries for name that was generated by jfairy using an OQL query with the predicate: `name LIKE &#39;randomCustomer.getName(">jfairy</a>&#39;`.</p>
<p><code>%</code> is the wildcard for OQL text searches.</p>
<h2 id="running-the-example">Running the Example</h2>
<h3 id="running-within-the-ide">Running within the IDE</h3>
<p>You can run the <code>CustomerServiceApplication</code> class from your IDE (e.g. Spring Tool Suite or IntelliJ IDEA).
From the IDE (STS) you can right click on the main class and runa spring boot app.
STS run command: <img src="/Users/wlund/Dropbox/git-workspace/wxlund/spring-geode-workshop/labs/images/run-spring-boot-app.png" alt="Alt"></p>
<h3 id="running-from-the-command-line">Running from the command line</h3>
<pre><code class="lang-bash">mvn clean <span class="hljs-class"><span class="hljs-keyword">package</span>`</span>
</code></pre>
<p>Then run the <code>CustomerServiceApplication</code> class from the command-line using the command </p>
<pre><code class="lang-bash">$ mvn spring-boot:<span class="hljs-keyword">run</span><span class="bash"></span>
</code></pre>
<p>We have just run our application taking advantage of SBDG to automatically detect that we are in local mode
with no connection to a gemfire cluster.  SBDG will create our region for us in memory and store our data
in a local cache or some refer to this configuration as a near cache.</p>
<h2 id="auto-configuration-for-apache-geode-take-one">Auto-configuration for Apache Geode, Take One</h2>
<p>While it is not apparent, there is a lot of hidden, intrinsic power provided by Spring Boot Data Geode (SBDG)
in this example.</p>
<h3 id="cache-instance">Cache instance</h3>
<p>First, in order to put anything into Apache Geode you need a cache instance. A cache instance is also required to
create <code>Regions</code> which ultimately store the application’s data (state). Again, a <code>Region</code> is a Key/Value data
structure, similar to a <code>java.util.Map</code>, mapping a Key to a Value or an Object.</p>
<p>SBDG is opinionated and assumes most Apache Geode applications will be client applications in Apache Geode’s
<a href="https://geode.apache.org/docs/guide/14/topologies_and_comm/book_intro.html"><em>Topologies and Communication</em></a>
Therefore, SBDG auto-configures a <code>ClientCache</code> instance by default. You can disable these features by
adding:</p>
<pre><code class="lang-java">    @<span class="hljs-keyword">SpringBootApplication</span>(<span class="hljs-keyword">exclude</span> = ClientCacheAutoConfiguration.class)
</code></pre>
<p>but in most case there is an easier way to move from a local ClientCache to a Client/Server Topology.</p>
<p>Without <em>auto-configuration</em> settin gup and runnning this quickly would not be possible. SBDG assumes
standard practices for the gemfire developer to be able to begin being productive immediately when using
Spring Boot</p>
<h2 id="switching-to-client-server">Switching to Client/Server</h2>
<p>Initially we want to get up and running as quickly as possible.  By not starting a locator/region and using
<em>@EnableClusterAware</em> we allow SBDG to detect that we are using a client <code>LOCAL</code> Region and we are not
required to start a cluster of Gemfire servers for the client to be able to store data. This allows
rapid local development for developers. </p>
<p>While client <code>LOCAL</code> Regions can be useful for some purposes (e.g. local processing, querying and aggregating of data),
it is more common for a client to persist data in a cluster of servers, and for that data to be shared by multiple
clients (instances) in the application architecture, especially as the application is scaled out to handle demand.</p>
<p>We continue with our example by switching from a local context to a client/server topology.</p>
<p>If you are rapidly prototyping and developing your application and simply want to lift off the ground quickly, then it
is useful to start locally and gradually migrate towards a client/server architecture.</p>
<p>To switch to client/server, all you need to do is startup a locator(s) and server(s) and SBDG will automatically
detect your topology. </p>
<p>There are several ways in which to start a cluster. For this example, we are going to use the tools provided with
Tanzu Gemfire, i.e. <em>Gfsh</em> (GemFire/Geode Shell). For this workshop, we have installed GFSH for you.  </p>
<p>To start the command shell locally, open a command/terminal prompt and type
$ gfsh</p>
<p><strong>Running Gfsh.</strong></p>
<pre><code class="lang-shell">        _________________________     __
       <span class="hljs-regexp">/ _____/</span> ______<span class="hljs-regexp">/ ______/</span> <span class="hljs-regexp">/____/</span> /
      <span class="hljs-regexp">/ /</span>  __<span class="hljs-regexp">/ /</span>___  <span class="hljs-regexp">/_____  /</span> _____  /
     <span class="hljs-regexp">/ /</span>__<span class="hljs-regexp">/ /</span> ____<span class="hljs-regexp">/  _____/</span> <span class="hljs-regexp">/ /</span>    <span class="hljs-regexp">/ /</span>
    <span class="hljs-regexp">/______/</span>_<span class="hljs-regexp">/      /</span>______<span class="hljs-regexp">/_/</span>    <span class="hljs-regexp">/_/</span>    <span class="hljs-number">1.12</span><span class="hljs-number">.1</span>

    Monitor and Manage Apache Geode
    gfsh&gt;
</code></pre>
<p>We have a script you can run from gfsh to start a Locator and Server in the simplest cluster:</p>
<pre><code class="lang-shell"><span class="hljs-keyword">cd</span> spring-geode-workshop/configuration
gfsh
gfsh&gt;<span class="hljs-keyword">run</span> --<span class="hljs-keyword">file</span>=configuration/src/main/resources/geode/bin/start-simple-<span class="hljs-keyword">cluster</span>.gfsh
</code></pre>
<p>You are set to go.</p>
<p>With our gemfire-cluster create with an two Apache Geode Locators and (Cache) Servers running we can verify by listing
and describing the members:</p>
<p><strong>List and Describe Members.</strong></p>
<pre><code>gfsh&gt;list members
   Name    | Id
---------- | ---------------------------------------------------
LocatorOne | <span class="hljs-number">10.99</span><span class="hljs-number">.199</span><span class="hljs-number">.24</span>(<span class="hljs-string">LocatorOne:</span><span class="hljs-number">68425</span>:locator)&lt;ec&gt;&lt;v0&gt;:<span class="hljs-number">1024</span>
ServerOne  | <span class="hljs-number">10.99</span><span class="hljs-number">.199</span><span class="hljs-number">.24</span>(<span class="hljs-string">ServerOne:</span><span class="hljs-number">68434</span>)&lt;v1&gt;:<span class="hljs-number">1025</span>


gfsh&gt;describe member --name=ServerOne
<span class="hljs-string">Name        :</span> ServerOne
<span class="hljs-string">Id          :</span> <span class="hljs-number">10.99</span><span class="hljs-number">.199</span><span class="hljs-number">.24</span>(<span class="hljs-string">ServerOne:</span><span class="hljs-number">68434</span>)&lt;v1&gt;:<span class="hljs-number">1025</span>
<span class="hljs-string">Host        :</span> <span class="hljs-number">10.99</span><span class="hljs-number">.199</span><span class="hljs-number">.24</span>
<span class="hljs-string">Regions     :</span>
<span class="hljs-string">PID         :</span> <span class="hljs-number">68434</span>
<span class="hljs-string">Groups      :</span>
Used <span class="hljs-string">Heap   :</span> <span class="hljs-number">27</span>M
Max <span class="hljs-string">Heap    :</span> <span class="hljs-number">3641</span>M
Working <span class="hljs-string">Dir :</span> <span class="hljs-regexp">/Users/</span>jblum<span class="hljs-regexp">/pivdev/</span>lab/ServerOne
Log <span class="hljs-string">file    :</span> <span class="hljs-regexp">/Users/</span>jblum<span class="hljs-regexp">/pivdev/</span>lab<span class="hljs-regexp">/ServerOne/</span>ServerOne.log
<span class="hljs-string">Locators    :</span> <span class="hljs-number">10.99</span><span class="hljs-number">.199</span><span class="hljs-number">.24</span>[<span class="hljs-number">10334</span>]

Cache Server Information
Server <span class="hljs-string">Bind              :</span> <span class="hljs-literal">null</span>
Server <span class="hljs-string">Port              :</span> <span class="hljs-number">40404</span>
<span class="hljs-string">Running                  :</span> <span class="hljs-literal">true</span>
Client <span class="hljs-string">Connections       :</span> <span class="hljs-number">0</span>
</code></pre><p>What happens if we try to run the application now?  You will find that because we use a default locator
port to connect to that our @EenableClusterAware annotation runs through logic that detects we are
now in client / server mode and will automatically connect us to the cluster, create the region
and persist our data into that regions.  If you have hundreds of application domain objects each
requiring a Region for persistence SBDG will enable the creation of those regions in your behalf.
It is not an unusual or unreasonable requirement in any practical enterprise scale application.</p>
<p>SBG through its integration with Spring Data Gemfire (SDG) is careful not to stomp on existing Regions
since those Regions may have data already. Declaring the @EnableClusterConfiguration` annotation,
which @EnableClusterAware automatically turns on for usm, is a useful development-time feature, but
it is recommended that you explicitly define and declare your Regions in production environments,
either using <em>Gfsh</em> or Spring confg. One of the additional benefits of @EnableClusterAware
annotation as you see above is that it will push configuration metadata from the client to the server (or cluster).
[Note: Cluster Configuration is outside the scope of our lab but ensures the meta data is consistent across all
nodes]</p>
<p>@EnableClusterAware comes from the Spring Data Gemfire (SDG)  project. SDG’s <code>@EnableClusterAware</code>
annotation makes it unnecessary to explicitly have to configure parameters like <code>clientRegionShortcut</code> on
the SDG <code>@EnableEntityDefinedRegions</code> annotation (or similar annotation, e.g. SDG’s <code>@EnableCachingDefinedRegions</code>).
Finally, because the SBDG&#39;s<code>@EnableClusterAware</code> annotation is meta-annotated with SDG’s <code>@EnableClusterConfiguration
annotation</code> is automatically configured with the <code>useHttp</code> attribute to <code>true</code>.</p>
<p>Now, we can run our application again, and this time, you will see you region created on the server you just
launched and can query for data. it just works!</p>
<p><strong>Client/Server Run </strong></p>
<pre><code class="lang-bash">.   ____          <span class="hljs-symbol">_</span>            <span class="hljs-symbol">__</span> <span class="hljs-symbol">_</span> <span class="hljs-symbol">_</span>
     /\\ / ___'<span class="hljs-symbol">_</span> <span class="hljs-symbol">__</span> <span class="hljs-symbol">_</span> <span class="hljs-symbol">_</span>(<span class="hljs-symbol">_</span>)<span class="hljs-symbol">_</span> <span class="hljs-symbol">__</span>  <span class="hljs-symbol">__</span> <span class="hljs-symbol">_</span> \ \ \ \
    ( ( )\___ | '<span class="hljs-symbol">_</span> | '<span class="hljs-symbol">_</span>| | '<span class="hljs-symbol">_</span> \/ <span class="hljs-symbol">_</span>` | \ \ \ \
     \\/  ___)| |<span class="hljs-symbol">_</span>)| | | | | || (<span class="hljs-symbol">_</span>| |  ) ) ) )
      '  |____| .<span class="hljs-symbol">__</span>|<span class="hljs-symbol">_</span>| |<span class="hljs-symbol">_</span>|<span class="hljs-symbol">_</span>| |<span class="hljs-symbol">_</span>\<span class="hljs-symbol">__</span>, | / / / /
     =========|<span class="hljs-symbol">_</span>|==============|___/=/<span class="hljs-symbol">_</span>/<span class="hljs-symbol">_</span>/<span class="hljs-symbol">_</span>/
     :: Spring Boot ::        (v2.0.9.RELEASE)

    Saving Customer [Customer(name=Jon Doe)]
    Querying <span class="hljs-keyword">for</span> Customer [SELECT * FROM /Customers WHERE name LIKE '%Doe']
    Customer was [Customer(name=Jon Doe)]

    Process finished with exit code <span class="hljs-number">0</span>
</code></pre>
<p>In the cluster (server-side), we will also see that the &quot;Customers&quot; Region was created successfully:</p>
<p><strong>List &amp; Describe Regions.</strong></p>
<pre><code class="lang-bash">    gfsh&gt;list regions
    List <span class="hljs-keyword">of</span> regions
    ---------------
    Customers


    gfsh&gt;describe region --name=/Customers
    ..........................................................
    Name            : Customers
    Data Policy     : partition
    Hosting Members : ServerOne

    Non-Default Attributes Shared By Hosting Members

     Type  |    Name     | Value
    ------ | ----------- | ---------
    Region | size        | <span class="hljs-number">1</span>
           | data-policy | PARTITION
</code></pre>
<p>We see that the &quot;Customers&quot; Region has a size of 1, containing &quot;Jon Doe&quot;.</p>
<p>We can verify this by querying the &quot;Customers&quot; Region:</p>
<p><strong>Query for all Customers.</strong></p>
<pre><code class="lang-bash">    gfsh&gt;query <span class="hljs-comment">--query="SELECT customer.name FROM /Customers customer"</span>
    Result : <span class="hljs-type">true</span>
    Limit  : 100
    Rows   : 1

    Result
    <span class="hljs-comment">-------</span>
    Jon Doe
</code></pre>
<p>That was easy!</p>
<h2 id="auto-configuration-for-apache-geode-take-two">Auto-configuration for Apache Geode, Take Two</h2>
<p>What may not be apparent in this example up to this point is how the data got from the client to the server. Certainly,
our client did send <code>Jon Doe</code> to the server, but our <code>Customer</code> class is not <code>java.io.Serializable</code>. So, how was an
instance of <code>Customer</code> streamed and sent from the client to the server then (it is using a Socket)?</p>
<p>Any object sent over a network, between two Java processes, or streamed to/from disk, must be serializable.</p>
<p>As further evidence, we can adjust our query slightly:</p>
<p><strong>Invalid Query.</strong></p>
<pre><code>gfsh&gt;query --query=<span class="hljs-string">"SELECT * FROM /Customers"</span>
Message<span class="hljs-keyword"> :</span> Could<span class="hljs-built_in"> not </span>create an<span class="hljs-built_in"> instance </span>of a class example.app.crm.model.Customer
Result <span class="hljs-keyword"> :</span> false
</code></pre><p>If you tried to perform a <code>get</code>, you would hit a similar error:</p>
<p><strong>Region.get(key).</strong></p>
<pre><code>gfsh&gt;get --region=/Customers --key=1 --key-class=java.lang.Long
Message<span class="hljs-keyword"> :</span> Could<span class="hljs-built_in"> not </span>create an<span class="hljs-built_in"> instance </span>of a class example.app.crm.model.Customer
Result <span class="hljs-keyword"> :</span> false
</code></pre><p>So, how was the data sent then? How were we able to access the data stored in the server(s) on the cluster with the
OQL query <code>SELECT customer.name FROM /Customers customer</code> as seen above?</p>
<p>Apache Geode and Tanzu GemFire provide 2 proprietary serialization formats in addition to <em>Java Serialization</em>:
{apache-geode-docs}/developing/data_serialization/gemfire_data_serialization.html[Data Serialization]
and {apache-geode-docs}/developing/data_serialization/gemfire_pdx_serialization.html[PDX], or <em>Portable Data Exchange</em>.</p>
<p>While <em>Data Serialization</em> is more efficient, PDX is more flexible (i.e. &quot;portable&quot;). PDX enables data to be queried
in serialized form and is the format used to support both Java and Native Clients (C++, C#) simultaneously. Therefore,
PDX is auto-configured in Spring Boot Data Geode (SBDG) by default.</p>
<p>This is convenient since you may not want to implement <code>java.io.Serializable</code> for all your application domain model
types that you store in Apache Geode. In other cases, you may not even have control over the types referred to by your
application domain model types to make them <code>Serializable</code>, such as when using a 3rd party library.</p>
<p>So, SBDG auto-configures PDX and uses Spring Data Geode’s <code>MappingPdxSerializer</code> as the <code>PdxSerializer</code> to de/serialize
all application domain model types.</p>
<p>If we were to disable PDX <em>auto-configuration</em>, you would see the effects of trying to serialize a non-serializable type,
<code>Customer</code>.  This would be apparent when you tried to query /Customers. We will leave this as an exercise for the student. </p>
<p>If you were not using SBDG, then you would need to enable PDX serialization explicitly.</p>
<p>The Spring Boot Data Geode/Gemfire PDX <em>auto-configuration</em> provided by SBDG is equivalent to:</p>
<p><strong>Equivalent PDX Configuration with Spring Data Gemfire.</strong></p>
<pre><code><span class="hljs-variable">@SpringBootApplication</span>
<span class="hljs-variable">@ClientCacheApplication</span>
<span class="hljs-variable">@EnableEntityDefinedRegions</span>(basePackageClasses = Customer.class)
<span class="hljs-variable">@EnableClusterConfiguration</span>(useHttp = true)
<span class="hljs-variable">@EnablePdx</span>
public class CustomerServiceApplication {
  <span class="hljs-comment">// ...</span>
}
</code></pre><p>In addition to the <code>@ClientCacheApplication</code> annotation, you would need to annotate the <code>CustomerServiceApplication</code>
class with SDG’s <code>@EnablePdx</code> annotation, which is responsible for configuring PDX serialization and registering
SDG’s <code>MappingPdxSerializer</code>.</p>
<p><a href="https://docs.spring.io/spring-gemfire/docs/current/reference/html/#samples"><em>Sample Applications</em></a>.</p>

<h1 id="look-aside-cache-pattern-example">Look-aside Cache Pattern Example</h1>
<p>This repo contains provides an example application demonstrating the use of
Tanzu GemFire as a <a href="https://content.pivotal.io/blog/an-introduction-to-look-aside-vs-inline-caching-patterns">look-aside cache</a>.</p>
<p>The application uses <a href="https://docs.spring.io/autorepo/docs/spring-boot-data-geode-build/current/reference/html5/">Spring Boot for Apache Geode</a> to cache data from the Bikewise.org public REST API. Look-aside caching is enabled with just a few annotations. When serving cached data, the application response time is dramatically improved.</p>
<h1 id="how-to-get-the-app-running-on-the-local-env-">How to get the app running on the local Env.</h1>
<p>We are going to work now with an application that will use the look-aside features of gemfire caching.  A standard spring-mvc app employs the use
of stereotypes.  These include:</p>
<ul>
<li>Domain Model</li>
<li>Java DSL for Configuration</li>
<li>Services</li>
<li>View Controllers</li>
<li>Spring MVC</li>
</ul>
<p>The web MVC framework we are using is Thyme Leaf but will not be covered in this workshop. We will only look at the java code involved in the integration
of Spring Boot Data Gemfire. Let&#39;s start with the domain.</p>
<h2 id="domain-object">Domain Object</h2>
<p>Our domain is examining reports on incidents that effect bikes within a grouping nearby and associated with a zipcode.  Our BikeIncident is structure to
capture a description of an incident.  Copy and paste this code into the <em>BikeIncident</em> class in the domain package.</p>
<pre><code class="lang-java">   <span class="hljs-keyword">private</span> <span class="hljs-built_in">String</span> <span class="hljs-keyword">type</span>;
    <span class="hljs-keyword">private</span> <span class="hljs-built_in">String</span> title;
    <span class="hljs-keyword">private</span> <span class="hljs-built_in">String</span> description;
    <span class="hljs-keyword">private</span> <span class="hljs-built_in">String</span> address;

    <span class="hljs-keyword">public</span> <span class="hljs-built_in">String</span> getType() {
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">type</span>;
    }

    <span class="hljs-keyword">public</span> <span class="hljs-built_in">String</span> getTitle() {
        <span class="hljs-keyword">return</span> title;
    }

    <span class="hljs-keyword">public</span> <span class="hljs-built_in">String</span> getDescription() {
        <span class="hljs-keyword">return</span> description;
    }

    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> setDescription(<span class="hljs-built_in">String</span> description) {
        <span class="hljs-keyword">this</span>.description = description;
    }

    <span class="hljs-keyword">public</span> <span class="hljs-built_in">String</span> getAddress() {
        <span class="hljs-keyword">return</span> address;
    }
</code></pre>
<h2 id="java-dsl-for-configuration">Java DSL for configuration</h2>
<p>We are going to add a few configurations to enable Spring Boot&#39;s AutoConfiguration that we learned about in Lab 2. First we annotate our
<em>LookAsideCacheApplicationConfig</em> class with the @Configuration so that Spring Boot will process our configurations.  We then tell it to
@EnableCachingDefinedRegions, which we will identify in our Service coming up next.  We then annotate it with @EnableClusterAware to take
advantage of SBDG&#39;s autoconfigruation so that we can develop from our IDE with a near-cache, with a local cache and by the end of this lab
you will see how to deploy and connect to your gemfire-cluster inside of kubernetes. Copy and paste this code into <em>LookAsideCacheApplicationConfig</em>
class within the <em>config</em> package.  [Note: we will use the @EnableStatics to show the difference in the speed of a cache access vs the
time taken to invoke the restful API]. </p>
<pre><code class="lang-java"><span class="hljs-variable">@Configuration</span>
<span class="hljs-variable">@EnableCachingDefinedRegions</span>
<span class="hljs-variable">@EnableStatistics</span>
<span class="hljs-variable">@EnableClusterAware</span>
</code></pre>
<h2 id="bikeincidentservice">BikeIncidentService</h2>
<p>Next we will add a service that takes the zipcode captured by our simple UI and calls out to a restful service to retrieve a report
of bike incidents for a given zipcode and surrounding area.</p>
<pre><code class="lang-java">    private <span class="hljs-keyword">final</span> RestTemplate restTemplate;

    <span class="hljs-meta">@Value</span>(<span class="hljs-string">"<span class="hljs-subst">${bikewise.api.url}</span>"</span>)
    private <span class="hljs-built_in">String</span> API_URL;

    public BikeIncidentService(RestTemplate restTemplate) {
        <span class="hljs-keyword">this</span>.restTemplate = restTemplate;
    }

    <span class="hljs-meta">@Cacheable</span>(<span class="hljs-string">"BikeIncidentsByZip"</span>)
    public <span class="hljs-built_in">List</span>&lt;BikeIncident&gt; getBikeIncidents(<span class="hljs-built_in">String</span> zipCode) throws IOException {

        <span class="hljs-built_in">String</span> jsonIncidents = restTemplate.getForObject(API_URL + zipCode, <span class="hljs-built_in">String</span>.<span class="hljs-keyword">class</span>);

        <span class="hljs-keyword">return</span> convertJsonToBikeIncidents(jsonIncidents);
    }

    private <span class="hljs-built_in">List</span>&lt;BikeIncident&gt; convertJsonToBikeIncidents(<span class="hljs-built_in">String</span> jsonIncidents) throws IOException {
        ObjectMapper objectMapper = <span class="hljs-keyword">new</span> ObjectMapper();
        objectMapper.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, <span class="hljs-keyword">false</span>);

        JsonNode bikeIncidentsAsJsonNode = objectMapper.readTree(jsonIncidents);

        <span class="hljs-built_in">List</span>&lt;BikeIncident&gt; bikeIncidents = objectMapper.convertValue(bikeIncidentsAsJsonNode.<span class="hljs-keyword">get</span>(<span class="hljs-string">"incidents"</span>),
                <span class="hljs-keyword">new</span> TypeReference&lt;<span class="hljs-built_in">List</span>&lt;BikeIncident&gt;&gt;(){});

        <span class="hljs-keyword">return</span> bikeIncidents;
    }
</code></pre>
<p>The important annotation to notice in this service is the <em>@Cacheable</em> that will enable the capturing of a list of bike incidents into a
<em>BikeIncidentsByZip</em> region that we&#39;ll be able to query from within Gemfire.</p>
<h2 id="view-controller">View Controller</h2>
<p>Next let&#39;s implement our View Controller.</p>
<p>Add the following code to the class <em>ViewController</em> in the controllers package:</p>
<pre><code class="lang-java">   <span class="hljs-meta">@Autowired</span>
    BikeIncidentService bikeIncidentService;

    <span class="hljs-keyword">private</span> List&lt;String&gt; responseTimes = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();

    <span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/"</span>)
    <span class="hljs-keyword">public</span> <span class="hljs-function">String <span class="hljs-title">homePage</span><span class="hljs-params">(Model model)</span> </span>{
        model.addAttribute(<span class="hljs-string">"zipCode"</span>);
        <span class="hljs-keyword">return</span> <span class="hljs-string">"home"</span>;
    }

    <span class="hljs-meta">@PostMapping</span>(<span class="hljs-string">"/"</span>)
    <span class="hljs-keyword">public</span> <span class="hljs-function">String <span class="hljs-title">requestIncidents</span><span class="hljs-params">(
            @RequestParam String zipCode,
            Model model)</span> <span class="hljs-keyword">throws</span> IOException </span>{

        <span class="hljs-keyword">long</span> timeStampBeforeQuery = System.currentTimeMillis();
        List&lt;BikeIncident&gt; bikeIncidents =
                bikeIncidentService.getBikeIncidents(zipCode);
        <span class="hljs-keyword">long</span> timeElapsed = System.currentTimeMillis() - timeStampBeforeQuery;

        recordNewDataRequest(timeElapsed, zipCode);
        populateModelWithSearchResults(model, bikeIncidents, zipCode);

        <span class="hljs-keyword">return</span> <span class="hljs-string">"home"</span>;
    }

    <span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">recordNewDataRequest</span><span class="hljs-params">(<span class="hljs-keyword">long</span> timeElapsed, String zipCode)</span> </span>{
        responseTimes.add( <span class="hljs-string">"Zip Code: "</span> + zipCode + <span class="hljs-string">", Response Time: "</span> + timeElapsed + <span class="hljs-string">" ms"</span>);
    }

    <span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">populateModelWithSearchResults</span><span class="hljs-params">(Model model, List&lt;BikeIncident&gt; bikeIncidents, String zipCode)</span> </span>{
        model.addAttribute(<span class="hljs-string">"zipCode"</span>, zipCode);
        model.addAttribute(<span class="hljs-string">"responseTimes"</span>, responseTimes);
        model.addAttribute(<span class="hljs-string">"bikeIncidents"</span>, bikeIncidents);
    }
</code></pre>
<p>There is nothing specific to Gemfire that is in this controller. We have autowired in the <em>BikeIncidentService</em> and invoke the service with the
zipcode parameter that is input into our search page.</p>
<h2 id="testing-your-application-functionality-locally">Testing your application functionality locally</h2>
<p>You should now be able to run your BikeIncident app locally with a local cache.  Simply start the spring boot application <em>LookAsideCacheApplication</em>
from your IDE or commandline.</p>
<pre><code class="lang-bash">gfsh&gt;<span class="hljs-literal">start</span> locator
gfsh&gt;configure pdx --<span class="hljs-attr">read-serialized=</span><span class="hljs-literal">true</span>
gfsh&gt;<span class="hljs-literal">start</span> server
</code></pre>
<p>Now run some queries on zip codes and do the following query:</p>
<pre><code class="lang-bash">gfsh&gt;<span class="hljs-keyword">query</span> --<span class="hljs-keyword">query</span>=<span class="hljs-string">"SELECT address, description FROM /BikeIncidentsByZip"</span>
</code></pre>
<p>#Section Two - deploying our application to Kubernetes
The fist thing we need to do is change our default profile from &quot;default&quot; to kubernetes, allowing us to retrieve our gemfire-cluster locators and servers
to connect to.</p>
<p>Open application.properties and uncomment the spring.profiles.active=kubernetes.  This will pick up the additional properties we need for the gemfire
cluster when we deploy our image.</p>
<h2 id="1-build-the-image">1.  Build the image</h2>
<p>Starting with Spring Boot 2.3, you can now run a comand and your build tool (maven or gradle) will build the Docker file for you.  For this application if you run:</p>
<pre><code class="lang-bash">./gradlew bootBuildImage
</code></pre>
<p>This creates an image for you on your local docker daemon.</p>
<h2 id="2-load-the-image">2. Load the image</h2>
<p>We now need to load the image into the kind environment.</p>
<pre><code class="lang-bash">kind <span class="hljs-keyword">load</span> docker-image docker.io/<span class="hljs-keyword">library</span>/look-aside-<span class="hljs-keyword">cache</span>:<span class="hljs-number">0.0</span><span class="hljs-number">.1</span>-<span class="hljs-keyword">SNAPSHOT</span>
</code></pre>
<h2 id="3-create-a-deployment">3. Create a deployment</h2>
<p>kubectl create deployment [my deployment name I make up] --image=[your look-aside-cache-image-name here]. -  this should create you a deployment,
replicaset, and pod using the image you build in step 1.</p>
<pre><code class="lang-bash">kubectl <span class="hljs-keyword">create</span> deployment look-aside-<span class="hljs-keyword">cache</span> <span class="hljs-comment">--image=docker.io/library/look-aside-cache:0.0.1-SNAPSHOT</span>
</code></pre>
<h2 id="4-expose-the-deployment">4. Expose the deployment</h2>
<p>You now need to expose the deployment so that you can access your website:  kubectl expose deployment/deployment-name --type=&quot;NodePort&quot; --port 8080</p>
<pre><code class="lang-bash">kubectl expose deployment look-aside-cache --<span class="hljs-class"><span class="hljs-keyword">type</span></span>=<span class="hljs-string">"NodePort"</span> --port <span class="hljs-number">8080</span>
</code></pre>
<p>You will now need the port exposed through the new service by doing the following:</p>
<pre><code class="lang-bash">kubectl <span class="hljs-keyword">get</span> services
</code></pre>
<p>and the output should look like the following:</p>
<pre><code class="lang-bash">NAME               TYPE        CLUSTER-<span class="hljs-built_in">IP</span>       EXTERNAL-<span class="hljs-built_in">IP</span>   PORT(S)          AGE
kubernetes         ClusterIP   <span class="hljs-number">10.96</span><span class="hljs-meta">.0</span><span class="hljs-meta">.1</span>        &lt;none&gt;        <span class="hljs-number">443</span>/TCP          <span class="hljs-number">4d22h</span>
look-aside-cache   NodePort    <span class="hljs-number">10.108</span><span class="hljs-meta">.118</span><span class="hljs-meta">.222</span>   &lt;none&gt;        <span class="hljs-number">8080</span>:*<span class="hljs-number">30615</span>*/TCP   17s
</code></pre>
<p>You will need your NodePort that is highlighed in bold.</p>
<h2 id="5-find-the-internal-ip-address">5.  Find the internal ip address</h2>
<p>Once the deployment has been exposed you will need to find your internal ip address and then add NodePort you created in the previous step.</p>
<pre><code class="lang-bash">kubectl <span class="hljs-keyword">get</span> nodes -o wide
</code></pre>
<p>and the output should look something similar to:</p>
<pre><code class="lang-bash">kubectl get nodes -o wide
NAME                 STATUS   ROLES    AGE     VERSION   INTERNAL-<span class="hljs-built_in">IP</span>   EXTERNAL-<span class="hljs-built_in">IP</span>   OS-IMAGE       KERNEL-VERSION   CONTAINER-RUNTIME
kind-control-plane   Ready    master   <span class="hljs-number">4d22h</span>   v1<span class="hljs-meta">.18</span><span class="hljs-meta">.2</span>   <span class="hljs-number">172.18</span><span class="hljs-meta">.0</span><span class="hljs-meta">.2</span>    &lt;none&gt;        Ubuntu <span class="hljs-number">19.10</span>   <span class="hljs-number">5.4</span><span class="hljs-meta">.0</span>-<span class="hljs-number">1021</span>-aws   containerd://<span class="hljs-number">1.3</span><span class="hljs-meta">.3</span>-<span class="hljs-number">14</span>-g449e9269
</code></pre>
